handle_output 
	    s->vq = virtio_add_queue(vdev, 128, virtio_blk_handle_output);

virtio_blk_handle_output{
	virtio_blk_handle_request()
} 

virtio_blk_handle_request()
{
	qemu_iovec_init_external ??
	virtio_blk_handle_read
	virtio_blk_req_complete
}

virtio_blk_handle_read()
{
	        virtio_blk_rw_complete(req, -EIO);
	ou
		bdrv_aio_readv (virtio_blk_rw_complete) 
}

------------------------------>

block.c

/obs: bdrv_aio_readv_em (emulator !bdrv_aio_readv)

bdrv_aio_readv
{
	bdrv_co_aio_rw_vector
}

bdrv_co_aio_rw_vector
{
	    co = qemu_coroutine_create(bdrv_co_do_rw);
	    qemu_coroutine_enter(co, acb);
}

coroutine_fn bdrv_co_do_rw(void *opaque)
{
	bdrv_co_do_readv || bdrv_co_do_writev
	acb->bh = qemu_bh_new(bdrv_co_em_bh, acb);
	qemu_bh_schedule(acb->bh);
}

coroutine_fn bdrv_co_do_readv() (analogo writev)
{
    ret = drv->bdrv_co_readv(bs, sector_num, nb_sectors, qiov);
}

bdrv_co_readv_em()  == bdrv_co_readv 
{
	bdrv_co_io_em
}

bdrv_co_io_em()
{
	chama como coroutine bs->drv->bdrv_aio_writev / _readv
		e passa bdrv_co_io_em_complete (bem com o co para retornar)
	-----> bdrv_aio_writev --> raw_aio_writev --> laio_submit
	qemu_coroutine_yield();
}

raw_aio_readv/writev()
{
	raw_aio_submit
}


static void bdrv_co_em_bh(void *opaque)
{
	qemu_bh_delete(acb->bh);
	qemu_aio_release(acb);
}

----------------------------------

.bdrv_aio_readv  (este negócio que faz cair no aio_submit, nada mais)
que é chamado no bdrv_co_io_em

laio_submit()
{
	io_prep_pwritev/readv()
	    io_set_eventfd(&laiocb->iocb, event_notifier_get_fd(&s->e));
	    if (io_submit(s->ctx, 1, &iocbs) < 0)
		--> deve configurar o callback para completion
}


